---
title: Helm Guide for Beginners. 
header:
  image: /assets/images/helm_banner.png
  teaser: /assets/images/helm.png
date: 2023-07-24 20:30:20 +0530
tags: 
  - kubernetes
  - helm
  - packagemanagement
categories: 
  - kubernetes
toc: true
toc_label: "Table of Contents"
toc_icon: "cog"
toc_sticky: true

---

In this article, we will learn about Helm, starting from its definition and covering its usage for deployment and debugging. You can use the toggle menu on the left-hand side to switch between different sections, as this is going to be a comprehensive topic with multiple subtopics to explore.

## 1. Introduction to Helm

### What is Helm?
Helm is an open-source package manager for Kubernetes, designed to simplify and streamline the deployment and management of applications on Kubernetes clusters. It allows users to define, install, and upgrade complex Kubernetes applications through reusable packages called Helm Charts. A Helm Chart is a collection of pre-configured Kubernetes resources, templates, and default values that can be easily customized and shared. With Helm, developers and operations teams can quickly deploy and manage applications in a consistent and efficient manner, reducing the complexity of Kubernetes deployment and enabling rapid iteration and scalability in the cloud-native ecosystem.

### Why use Helm for Kubernetes deployments?
Helm simplifies and streamlines Kubernetes deployments by providing a package manager for managing pre-configured application components called "Charts." With Helm, developers can easily share, version, and deploy applications consistently. It abstracts Kubernetes complexities, allowing users to define configurations as code and automate repetitive tasks. Helm also enables effortless rollbacks, updates, and version management. As a result, Helm accelerates the deployment process, promotes reusability, enhances collaboration, and ensures consistency across Kubernetes clusters, making it an indispensable tool for efficient and scalable Kubernetes deployments.

### Helm Features and Benefits
Helm simplifies Kubernetes application deployment by providing a package manager for managing pre-configured charts. Its key features include: 

1. Package Management: Helm packages, called charts, encapsulate Kubernetes resources and their configurations, making deployment and sharing easy.

2. Versioning and Rollbacks: Helm enables version control of releases, enabling seamless rollbacks and updates.

3. Template Engine: Charts use Go templates for dynamic resource generation based on user-defined values.

4. Reusability: Helm Charts can be shared and reused, accelerating application development and collaboration.

5. Scalability: Helm streamlines managing complex Kubernetes deployments, enhancing scalability and maintainability.

By streamlining deployment, versioning, and configuration management, Helm accelerates Kubernetes adoption and enhances application lifecycle management.

### Helm Architecture Overview
Helm is a package manager for Kubernetes that simplifies application deployment. Its architecture comprises two main components: Helm Client and Tiller (Helm Server). The Helm Client is a command-line tool that interacts with Kubernetes, manages charts, and generates YAML manifests based on user input. Tiller, a server-side component, runs within the Kubernetes cluster and manages chart releases by installing, upgrading, and deleting them. It stores release information in Kubernetes ConfigMaps. Helm uses charts, which are packages of pre-configured Kubernetes resources, enabling users to deploy complex applications effortlessly. The separation of Helm Client and Tiller enhances security and enables easy collaboration and version control.

## 2. Installing Helm

### Installing Helm on different platforms (Linux, macOS, Windows)
Installing Helm on different platforms, including Linux, macOS, and Windows, is a straightforward process. Here's how you can install Helm on each platform:

1. Linux:
   - Use package managers like `apt` (Ubuntu/Debian) or `yum` (CentOS/RHEL) to install Helm.
   - Example for Ubuntu/Debian:
     ```
     curl -fsSL -o get_helm.sh https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3
     chmod +x get_helm.sh
     ./get_helm.sh
     ```

2. macOS:
   - Use Homebrew to install Helm on macOS.
   - Install Homebrew first (if not already installed):
     ```
     /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
     ```
   - Install Helm:
     ```
     brew install helm
     ```

3. Windows:
   - Download the Helm Windows executable from the official Helm GitHub releases page (https://github.com/helm/helm/releases).
   - Extract the downloaded ZIP file and place the `helm.exe` binary in a directory included in the system's PATH variable.

After installation, verify Helm by running `helm version` on the command line. This confirms that Helm is successfully installed on your respective platform and ready for use.

### Setting up Helm on Kubernetes clusters
Setting up Helm on Kubernetes clusters involves a few steps to get Helm initialized and ready for managing applications on the cluster. Here's a high-level overview of the process:

1. **Install Helm CLI**: Start by installing the Helm client (CLI) on your local machine or the system from which you want to manage the Kubernetes cluster. Follow the installation instructions based on your operating system as mentioned in the previous answer.

2. **Initialize Helm**: Run the following command to initialize Helm on your Kubernetes cluster:

   ```
   helm init
   ```

   This command installs the necessary components, including the Tiller server (Helm's in-cluster component), and sets up the configuration.

3. **Wait for Tiller to be Ready**: Wait for Tiller to be fully deployed and ready on the cluster. You can check the status by running:

   ```
   kubectl get pods --namespace kube-system
   ```

   Look for the `tiller-deploy` pod to be in the "Running" state.

4. **Add Helm Charts Repositories**: Helm uses repositories to fetch pre-packaged applications (charts). You can add official Helm repositories and any custom repositories you need:

   ```
   helm repo add stable https://charts.helm.sh/stable
   ```

5. **Update Helm Repositories**: After adding repositories, update them to get the latest available charts:

   ```
   helm repo update
   ```

6. **Deploy Applications**: Now you are ready to deploy applications using Helm charts. For example, to install an application from the stable repository:

   ```
   helm install my-app stable/<chart-name>
   ```

7. **Upgrade and Manage Applications**: Helm enables you to upgrade, rollback, and manage the lifecycle of your applications easily.

Remember to manage access to Tiller carefully, especially in production environments. You can secure Tiller using Role-Based Access Control (RBAC) and secure network policies.

Helm simplifies the process of deploying and managing applications on Kubernetes clusters, making it a valuable tool for DevOps teams.

### Helm Client and Tiller (Helm Server) components
As of Helm 3, Tiller (Helm Server) has been deprecated and is no longer used. In Helm 2, Tiller was a server-side component that ran within the Kubernetes cluster and managed chart releases. It acted as the in-cluster server for Helm and was responsible for deploying and managing charts on behalf of the Helm client.

However, Tiller had some security and operational concerns, which led to its deprecation and removal in Helm 3. Helm 3 introduced a significant change by removing Tiller altogether, making Helm a client-only tool. This means that Helm 3 no longer requires Tiller to be installed in the Kubernetes cluster.

With the removal of Tiller, Helm 3 now communicates directly with the Kubernetes API server using the Kubernetes Service Account credentials, removing the need for a separate in-cluster component. This change improved the security and simplicity of Helm deployments.

So, in Helm 3, there is no Tiller (Helm Server) component. The Helm client is the only component you need to interact with and manage your Kubernetes cluster using Helm charts.

## 3. Helm Charts Fundamentals

### What are Helm Charts?
Helm Charts are packages used to define, install, and manage applications on Kubernetes clusters. They are a fundamental part of Helm, the package manager for Kubernetes. A Helm Chart contains all the Kubernetes manifest files (YAML) required to deploy a specific application or service, along with configurable templates that allow users to customize the deployment.

Helm Charts simplify the process of deploying complex applications by providing a standardized and repeatable way to package and deploy Kubernetes resources. Charts can be easily shared and versioned, allowing for collaboration and reuse across different projects and teams.

Using Helm Charts, developers and operators can define application dependencies, configure values, manage application releases, and perform upgrades or rollbacks seamlessly. Official Helm Charts are available from the Helm Hub, and users can also create and publish custom Charts to share their applications and configurations with the Kubernetes community.

### Chart Structure and Components
The Helm Chart structure consists of specific directories and files that define the components and configuration of the packaged application or service. Here is an overview of the key components within a Helm Chart:

1. **Chart.yaml**: This file contains metadata about the Chart, including the name, version, description, and other information.

2. **values.yaml**: This file defines the default configuration values for the application. Users can override these values during deployment to customize the behavior of the application.

3. **templates**: This directory contains Kubernetes manifest files written in YAML, with embedded Go Template code. These templates are used to generate the final Kubernetes YAML manifests during Chart installation.

4. **charts**: This directory allows you to include subcharts or dependencies for your Chart. Subcharts are Charts that are included within the main Chart.

5. **templates/NOTES.txt**: This file provides optional post-installation notes or instructions for the user after the Chart is deployed.

6. **requirements.yaml**: This file specifies the dependencies for the Chart. It can define other Charts that must be present for this Chart to work correctly.

7. **templates/_helpers.tpl**: This file contains helper templates that can be used within other templates to improve code reusability and maintainability.

By leveraging this directory structure and the YAML files, Helm provides a powerful and organized way to package and deploy applications on Kubernetes clusters. Users can easily customize and manage their applications using Helm Charts, simplifying the process of managing complex Kubernetes deployments.

### Understanding Chart Templates and Values
Helm Chart Templates and Values are key concepts that allow users to customize and deploy applications on Kubernetes clusters effectively. Let's delve into each concept:

1. **Helm Chart Templates**:
   Helm Chart Templates are Kubernetes manifest files written in YAML format, but they include embedded Go Template code. These templates serve as blueprints for the resources (such as Deployments, Services, ConfigMaps, and more) that will be deployed on the Kubernetes cluster.

   The Go Template code allows dynamic generation of the YAML manifests based on configurable values and logic defined in the Chart. For example, templates can use conditional statements, loops, and variables to create resources tailored to specific deployment scenarios.

   During Helm Chart installation, the Go Template code is rendered, and the resulting YAML manifests are applied to the Kubernetes cluster.

2. **Helm Chart Values**:
   Helm Chart Values are configuration settings used to customize the deployment of the application. They are defined in the `values.yaml` file within the Chart.

   Users can override default values provided in the `values.yaml` file during installation, allowing them to customize the behavior of the application. By providing a set of values specific to their use case, users can adapt the Chart to different environments and requirements.

   Values can include various data types such as strings, integers, booleans, and lists, and they can be accessed within the Chart Templates using the Go Template syntax.

By combining Helm Chart Templates and Values, Helm allows for dynamic and flexible application deployments. Users can easily configure and manage their applications without the need to edit the underlying YAML files directly, making the process more user-friendly and reusable.

### Using Chart Repositories
Helm Chart Repositories are essential for sharing and distributing Helm Charts across different teams, projects, and organizations. A Helm Chart Repository is a location where Helm Charts are stored, and users can access and install these Charts from the repository using Helm commands. Here's how to use Helm Chart Repositories:

1. **Adding Helm Chart Repositories**:
   To add a Helm Chart Repository, use the `helm repo add` command and provide a name and URL for the repository. For example:
   ```
   helm repo add my-repo https://example.com/charts
   ```
   After adding the repository, Helm updates its local repository cache, making the Charts from that repository available for installation.

2. **Listing Helm Chart Repositories**:
   To view the list of added Helm Chart Repositories, use the `helm repo list` command:
   ```
   helm repo list
   ```

3. **Searching for Helm Charts**:
   You can search for available Helm Charts within the added repositories using the `helm search repo` command. For example:
   ```
   helm search repo my-chart
   ```

4. **Installing Helm Charts**:
   To install a Helm Chart from a specific repository, use the `helm install` command followed by the repository name and Chart name. For example:
   ```
   helm install my-release my-repo/my-chart
   ```

5. **Updating Helm Chart Repositories**:
   To ensure that you have the latest version of the Charts from the repositories, periodically update the repository cache using the `helm repo update` command:
   ```
   helm repo update
   ```

6. **Creating Custom Helm Chart Repositories**:
   If you have your own Helm Charts that you want to share with others, you can create a custom Chart repository. This involves hosting the Charts in a public or private server or a cloud-based storage service. The repository needs to be accessible via a URL so that users can add it using the `helm repo add` command.

By using Helm Chart Repositories, teams and developers can easily access, share, and manage Helm Charts, promoting reusability and consistency across different Kubernetes deployments.

## 4. Creating and Managing Helm Charts

Creating and managing Helm Charts involves a series of steps to package applications or services for deployment on Kubernetes clusters. Let's walk through the process with some examples:

### Step 1: Create a New Helm Chart

Use the `helm create` command to create a new Helm Chart skeleton with the following command:

```bash
helm create my-chart
```

This creates a new directory named `my-chart` with the basic Helm Chart structure.

### Step 2: Define the Kubernetes Resources

Navigate to the `my-chart/templates` directory, where you will find sample YAML files for Kubernetes resources like `deployment.yaml`, `service.yaml`, etc. Modify or add resources as required for your application.

For example, in `deployment.yaml`:

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: {{ include "my-chart.fullname" . }}
  labels:
    app: {{ include "my-chart.name" . }}
spec:
  replicas: {{ .Values.replicaCount }}
  selector:
    matchLabels:
      app: {{ include "my-chart.name" . }}
  template:
    metadata:
      labels:
        app: {{ include "my-chart.name" . }}
    spec:
      containers:
        - name: {{ .Chart.Name }}
          image: "my-image:latest"
          ports:
            - containerPort: 80
```

### Step 3: Define Chart Values

In `my-chart/values.yaml`, define default configuration values for your application:

```yaml
replicaCount: 1
image:
  repository: "my-image"
  tag: "latest"
```

### Step 4: Customize the Chart

Users can override default values during installation. For example, install the Chart with 3 replicas:

```bash
helm install my-release my-chart --set replicaCount=3
```

### Step 5: Package and Share the Chart

Package the Chart using the `helm package` command:

```bash
helm package my-chart
```

This creates a `my-chart-version.tgz` file.

You can share this Chart by hosting it on a public or private repository, or share it directly with others.

### Step 6: Installing and Managing Releases

To install the Chart, use the `helm install` command:

```bash
helm install my-release my-chart
```

To upgrade or rollback releases:

```bash
helm upgrade my-release my-chart
helm rollback my-release
```

By following these steps, you can create, manage, and share Helm Charts to simplify application deployments on Kubernetes clusters.

### Helm Hooks (Pre and Post Install/Upgrade)
Helm Hooks are special resources in Helm Charts that allow you to run pre and post-install/upgrade jobs or actions during the Chart deployment lifecycle. They provide a way to execute custom scripts or commands at specific points in the installation or upgrade process. Helm Hooks are particularly useful for performing tasks such as database migrations, initializing configurations, or integrating with external systems.

Hooks can be defined in the Chart's `templates/hooks` directory and are managed separately from other Kubernetes resources. Here's how to use Helm Hooks:

1. **Defining Hooks**: Create YAML files within the `templates/hooks` directory of your Helm Chart to define the pre and post-install/upgrade hooks. For example, `pre-install.yaml`, `post-install.yaml`, `pre-upgrade.yaml`, and `post-upgrade.yaml`.

2. **Hook Types**: There are three types of Helm Hooks:
   - `pre-install` and `pre-upgrade`: These hooks run before the installation or upgrade of the Chart.
   - `post-install` and `post-upgrade`: These hooks run after the installation or upgrade of the Chart.

3. **Hook Specifications**: Within the hook YAML files, use the `hook` field to specify the hook type and the `manifest` field to include the YAML manifest for the hook. For example:

```yaml
# templates/hooks/pre-install.yaml
apiVersion: batch/v1
kind: Job
metadata:
  name: {{ include "my-chart.fullname" . }}-pre-install
  annotations:
    "helm.sh/hook": pre-install
    "helm.sh/hook-weight": "-5"
spec:
  template:
    spec:
      containers:
      - name: my-custom-container
        image: my-custom-image
        command: ["sh", "-c", "echo Running pre-install hook"]
```

4. **Hook Annotations**: Add the `helm.sh/hook` and `helm.sh/hook-weight` annotations to indicate that the resource is a Helm Hook and specify the order in which the hooks should be executed (lower values run first).

5. **Running Hooks**: When you install or upgrade the Chart, Helm automatically runs the corresponding hooks at the appropriate stage of the deployment lifecycle.

Hooks are a powerful feature in Helm Charts that enable you to perform additional actions and configurations during installation or upgrade, making it easier to integrate your application with the Kubernetes cluster and external systems. However, be cautious while using hooks, as they may introduce dependencies and timing considerations in the deployment process.

### 5. Chart Templating with Helm

- Understanding Helm Template Language (Go Template)
- Using Conditionals and Loops in Chart Templates
- Configuring Chart Values and Values Files
- Templating Best Practices

### 6. Helm Deployments and Upgrades

- Deploying Charts to Kubernetes Clusters
- Managing Releases with Helm
- Upgrading and Rolling Back Releases
- Uninstalling Helm Releases

### 7. Helm Repositories

- Working with Chart Repositories
- Setting up Private Helm Repositories
- Using External Chart Repositories

### 8. Helm and Kubernetes Configurations

- Helm and Kubernetes Configurations Interaction
- Overriding Default Values with ConfigMaps and Secrets
- Using External Values Files

### 9. Customizing and Extending Helm Charts

- Creating Configurable Charts with Values
- Chart Dependencies and Subcharts
- Helm Library Charts

### 10. Helm Testing and Quality Assurance

- Helm Testing with Helm Test Hooks
- Linting Helm Charts
- Helm Dry-Run for Release Simulation

### 11. Helm and Continuous Deployment

- Integrating Helm into CI/CD Pipelines
- Helm Version Management in CI/CD
- Best Practices for Helm in CI/CD

### 12. Helm and Security Best Practices

- Securing Helm Tiller
- Role-Based Access Control (RBAC) for Helm
- Secure Helm Chart Development

### 13. Advanced Helm Concepts (Optional)

- Helm Plugins
- Using Helm with Custom Resource Definitions (CRDs)
- Helm and Kubernetes Operators

### 14. Helm and Other Kubernetes Ecosystem Tools

- Helm and Kustomize
- Helmfile and Helm Diff

### 15. Hands-on Labs and Exercises

- Practical exercises to apply Helm concepts
- Deploying applications using Helm Charts

### 16. Helm Troubleshooting and Debugging

- Common Helm Deployment Issues and Solutions
- Debugging Helm Charts and Releases